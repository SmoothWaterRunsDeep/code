#### 强制类型转换

一个变量的类型在创立的时候就已经确定了，进行强制转换时，如(float)i，它只不过是一个表达式而已

#### 内存

十六进制刚好两位组成一个字节，用来表示内存是非常合适的，一目了然

Intel的内存都是采用小端存储。小端存储便于数据的截断

malloc出来的空间允许存储任何类型的数据，因此你需要给他的类型强转一下，转成你想要的类型。

#### scanf

- 从键盘输入到缓冲区里的实际上都是字符串，之所以在scanf里要写明数据的类型是因为scanf要根据你的数据类型来把字符串转换成对应的数据类型来存储到变量对应的空间里，也因此变量必须要取地址。


- 由于输入完成后必须要回车才能触发scanf的匹配，所以每一次我们输入的内容最后面肯定会有一个\n，所以如果读取整型和读取字符连在一起，你在输入你想输的整数之后根本没有机会输字符串就结束了，因为你上一次scanf后留下来的\n被读走了。


- 由于%c不会忽略任何字符，所以使用scanf读取多个变量的时候，要在%c前面加上一个空格来抵消掉你用于间隔而输入的那个空格。

- scanf在读取字符串类型的时候会自动在最后加上'\0'

```c
char c[10]="123456789";
scanf("%s",c);
//假如你在这里输入的是hello,那么字符数组c里面的内容是'h','e','l','l','o','\0','7','8','9'
printf("%s\n",c);//那么这个打印的结果会是hello，而不会把后面的内容继续打印出来，因为scanf在读取hello的时候在它后面加上了'\0',因此printf在匹配到'\0'就停止了
```

- scanf只能读取连续的字符串，如果是中间有空格的一段句子就不行了。比如"how are you"，那么它只会读取到how，因为scanf除了读取%c，其它时候是会忽略空格的，所以它读取到空格的时候就停止匹配了。那么像这种情况使用gets/puts函数比较好。

- 为a多次赋值

```c++
char c;
while(scanf("%c",&c)){
    if('\n'==break){
        break;//读取到换行就结束
    }
}
//注意char类型的数据在scanf的时候每次真的就只会读取一个字符，比如你在scanf的时候输入一个abc，它就会读走a，而剩下的bc以及你结束scanf时输入的那个换行就留在缓冲区里了
```



#### 断点

比如说int i；把断点打在这个语句旁边是不会停留的，但是如果给它赋值了，比如说int i=10；那就会停留在这一句了。因为定义变量这个语句是不用得到执行的，编译器会自己给它分配空间的。

#### CLion

​	CLion和MAC的文件编码格式都是UTF-8，其实CLion是可以支持中文路径的，只不过是为了跨平台。因为Windows它有自己的一套编码格式，它用的是gbk编码，所以只要把代码配置改成gbk就可以支持中文路径了，但是这样的话如果把代码打包发给MAC系统打开的话，因为MAC是采用UTF-8编码的，那它是会乱码的。

​	CLion使用的是C99标准，仍然支持gets，但是vs它把gets给去掉了，vs使用的是fgets();

​	在项目中新建文件的时候应勾选“添加到目标”，如果你不是在项目中新建的项目，而是手动拖进项目里的，那么你要自己去CMakeListTxt里的最后一行的括号里，把你的文件名给手动输入进去



#### 逻辑判断

​	不能使用连续不等号来进行逻辑判断，比如3<a<10;这个表达式永远是真值，因为如果a小于3的话，那么从左往右判断3<a的时候它的判断值为0，然后0<10为真。如果a>3的话，那么从左往右判断3<a的时候它的判断值为1，然后1<10为真，故这个表达式会永远为真。

​	短路运算有时可以帮我们简略代码，比如i&&printf("hello");那我们就不需要再使用一个if语句去判断i的值是否为0了。同理逻辑或也是有短路运算的，i||printf("hello");当i为真的时候就不会执行后面的printf了，只有i为假的时候才会执行printf。

#### 简写

简写是可以提高编译速度的，但是在执行上是没有区别的。比如a+=10;



#### oj

- 在oj里写的函数如果不需要返回值的就把函数类型设置为void，否则会报runtime error的错误


- 有时输出里需要换行，这也会影响到答案的正确性


- 有的oj里面如果把编译选项设置成C++,需要自己把C的头文件给打上，如果编译选项是C，它是自己包含头文件的，可以不用引用C的头文件
- oj的输入很严格，在循环读取时，你一般是不能用x!=9999来作为判断边界的，因为这样的话你多读取了一个9999，oj会报出runtime error这样的错误。


#### 循环

​	在while循环中使用continue要稍微注意一点，如果continue在i++的前面，那么执行了continue之后i++就不会得到执行然后直接进入下一次循环但是由于此时的i值得不到改变所以可能会陷入死循环。

​	嵌套循环

```c
for(int i=1;i<6;i++){//为什么这里i不从0开始呢，主要是因为i如果从0开始的话那么第一次的时候内层循环是不会执行的，也就等于说让i从i=0开始是没有意义的，所以让i从1开始
for(int j=0;j<i;j++){
    print("*");
}
}
```



#### 数组

数组和结构体都是属于结构类型的数据。

编译器它有自动根据你初始化的数据个数来计算你的数组长度的功能，但是初试的时候不要这么写，因为这样写会让老师数你的元素个数让老师很麻烦。

虽说最新的C标准允许定义数组的时候使用变量来描述数组长度，不过很多编译器较老的版本都不支持这种写法，但是在访问数组元素的时候还是可以在中括号里使用变量的

```c
int index=5;
int a[index]={1,2,3,4,5};//错误
printf("%d",a[index]);//正确
```

使用数组作为参数进行传递的时候它是弱化成指针传过去的，即传过去的是数组的起始地址

```c
int a[5]={1,2.3,4,5};
int print(int a[]){
printf("%d",a[3]);
}

int main(){
print(a);//这个传过去的是数组指针
print(a[5]);//这个传过去的是a[5]这个数据，虽然说访问越界了，但是你如果这么干，它会报错invalid conversion from 'int' to 'int*'就是说你不能传递int型变量给int *型
}

```



#### 字符数组

- 字符数组就代表一个字符串，所以想打印一个字符串就使用%s来对应数组名即可，它在背后打印的时候如果遇到了字符数组最后的'\0'就会自动结束打印。


```c
char a[5]="hello";
printf("%s",a);
//但是这样子打印会乱码，因为如果你的字符串大小刚刚好是数组的大小，那它最后就没有结束符'\0'，但是它打印的话是会一直遇到'\0'才结束打印的，因此就会乱码，所以正确方式应该是a[6]="hello"，这样它就能在最后插入'\0'了

//打印字符数组的背后过程
int i=0;
while(a[i]){
    printf("%c",a[i]);
    i++;
}
```

另外说一句，strcmp是从前往后比较对应字母的ASCII码值，而非比较两个字符串的长度。

- C里面的翻转字符串

```c
char a[10],b[10]={0};//给b初始化为0可以让字符串翻转之后有结束符
gets(a);
int l=strlen(a);
for(int i=0;i<l;i++){
    b[i]=a[l-1];
}
```



#### 指针

```c
int a[10]={1,2,3,4,5};
int * p;
for(int i=0;i<5;i++)
    printf("%d",*(p+i);//通过指针的偏移来得到a[i]
//并且*(P+i)与p[i]是等价的，编译器在编译时，数组取下标的操作正是转换为指针偏移来完成
```



在使用malloc申请堆空间的时候返回的是void *类型的指针，但是void *类型的指针不能进行偏移，所以我们都会在使用malloc的时候对它进行强转。malloc函数使用的头文件是stdlib.h

==注意使用函数返回一个指针的时候，你这个指针指向的空间一定不可以是栈空间里的，因为随着函数的执行结束，你这段空间也会随之被回收。==



```c++
BtNode*parent,*order=T->lchild;//你这句代码，只有后面的order可以被赋值为T->lchild，而parent是赋不到值的
```

#### 函数

​	你用的函数如果不写返回类型的话，它默认你的类型是int，但是如果你的函数定义在使用的后面，而且你定义函数时使用的不是int类型，编译器就会给你警告说你的函数类型冲突。如果你的函数定义真的要放在main函数的后面的话，那你可以在使用函数之前先把这个函数声明一下。

​	ctrl+鼠标左键就可以跳转到对应函数部分的代码

函数的声明是为了把函数的类型、名字、形参的类型、个数、顺序通知编译程序，以便后续编译器识别该函数并检查该函数的调用是否合法。

==函数名中存储的是函数的入口地址，也是一个指针，是函数指针类型==。如果你把函数指针当作一个参数传递给了另一个函数，那么你可以认为是给那个函数传递的是一种行为。

#### 头文件

使用双引号括起来的头文件是说在当前目录下寻找你自己定义的头文件，而尖括号括起来的头文件是标准库里的头文件

#### 编写习惯

​	由多个源程序文件组成C程序可以提高编译效率，因为CPU是多核的，分成多个源文件可以让多核同时工作，这个核编译这个文件，那个核编译那个文件。

​	由于全局变量和局部变量有可能重名，编译器采取的是就近原则，所以有时候可能程序运行结果是我们预期之外的，所以应尽可能避免使用全局变量

命名规范：

1. 下划线命名法（如：list_insert）
2. 驼峰命名法（如：ListInsert）

==函数如果实现在另一个源文件中，而你想在你的主文件中使用这个函数，那么需要在你引用的头文件里先声明一下这个函数==

#### 变量

##### 局部变量与全局变量

局部变量只在离自己最近的大括号内有效

```c
int main(){
    {
        int i=10;
    }
    printf(“%dn\n”,i);//这里会报错说变量i没有被声明，是第一次被使用
}
```

被花括号括起来的这部分语句我们称之为复合语句，这种复合语句也称之为“分程序”或“程序块”，在复合语句中定义的变量只在本复合语句中有效。

全局变量其实不一定在整个程序中都能发挥作用，它的作用范围是从它定义开始到程序的末尾。

```c
int main(){
prinf("%d",j);//此处会报错,因为编译器到这里还看不到变量j
}
int j=10;
```

并且全局变量始终在程序执行过程中在数据段占据存储单元，所以全局变量应尽量避免使用。而且如果函数的执行依赖于外部变量也不利于函数的移植，可能你把这个函数移到另一个文件中那个文件中刚好就也有一个和你这个函数需要的那个外部变量的名字相同的变量，就可能会出现错误。

##### 静态变量与全局变量

静态变量与全局变量都只会初始化一次，而区别是静态变量只在函数内有效。



#### 递归

```c
int f(int n){    //斐波那契数列
if(1==n||2==n)
  reutrn n;
return f(n-1)+f(n-2);}
int main(){
int x;
scanf("%d",&x);
printf("%d",f(x));
return 0;}
```

​	这个楼梯，其实是有点递增的感觉，就是你只能跨一步或两步，但是它已经把你第一个楼梯和第二个楼梯的跨法给列出来了，剩下你顶多你从第三个楼梯开始算，你到第三个楼梯要么从第一个楼梯跨上来要么从第二个楼梯跨过来，而第一个楼梯和第二个楼梯的跨法已经知道了，所以加起来就是第三个楼梯的跨法，那么现在已知第二个楼梯和第三个楼梯的跨法，所以第四个楼梯的跨法也能够知道了，以此类推就能够知道第n个楼梯的跨法了。

​	所谓递归就是先压栈压到底然后再往回走。所以我归根到底还是从第一个和第二个楼梯那里加过来的。

#### 结构体

结构体的数据对齐是按照它的最大成员数据类型的整数倍来对齐的

```c
struct student{//最大数据类型是int型
    int i;
    char a[20];//20B，刚好的4的整数倍，可以对齐
    char j;//1个字节，需要再补3个字节才能对齐
    float k;//4个字节，可以对齐
    char b[30];//30个字节，需要再补2个字节才能对齐
}
```

之所以对齐是为了CPU高效的去取内存里的数据

如果两个数据成员的大小之和小于等于最大数据类型的大小，那么就可以不用进行扩展，所以调整结构体的数据成员的顺序也可以帮助我们更加节省结构体占用的空间

```c
struct student{//这里最大数据类型显然是double，占8个字节
    double i;
    int j;//由于j和c的大小加起来小于8个字节，所以可以把它们放在一块，算8个字节
    char c;
}
```



#### 调试

如果在main函数里打断点但是看不到你的变量，可以看看你写的函数有没有加引用，并且也要注意你的变量是不是写在了test函数里，注意你的test函数是一个栈函数，当函数执行完毕后空间就会被回收掉。





#### 库函数

memecpy是一个内存copy接口，strcpy仅能copy字符型数组，而memcpy既可以copy整数型数组还能copy浮点型数组。

```c++
memcpy(ST.elem,sizeof(A));//把一段连续的内存的数据放到另一端连续的内存上
```

